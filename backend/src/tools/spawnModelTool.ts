/**
 * Spawn Model Tool
 *
 * –°–ø–∞–≤–Ω–∏—Ç 3D –º–æ–¥–µ–ª—å –∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –≤ —Å—Ü–µ–Ω—É.
 * –î–æ–±–∞–≤–ª—è–µ—Ç Interactable + Grabbable + TwoHandsGrabbable (–¥–ª—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è).
 *
 * Flow:
 * 1. –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏ –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ
 * 2. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç TypeScript –∫–æ–¥ —Å GLTFLoader
 * 3. –ó–∞–ø–∏—Å—ã–≤–∞–µ—Ç –≤ src/generated/
 * 4. Hot-reload —á–µ—Ä–µ–∑ WebSocket
 */

import { betaZodTool } from '@anthropic-ai/sdk/helpers/beta/zod';
import { z } from 'zod';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { logger } from '../utils/logger.js';
import { getModelMeta, getModelGlbPath, modelExists } from './modelUtils.js';
import { getLiveCodeServer } from './injectCode.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const GENERATED_DIR = path.join(__dirname, '../../../src/generated');

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ –¥–ª—è —Å–ø–∞–≤–Ω–∞ –º–æ–¥–µ–ª–∏
 */
function generateSpawnCode(options: {
  modelId: string;
  modelPath: string;
  position: [number, number, number];
  scale: number;
  grabbable: boolean;
  scalable: boolean;
  scaleMin: number;
  scaleMax: number;
  hasAnimations: boolean;
  animationName?: string;
}): string {
  const {
    modelId,
    modelPath,
    position,
    scale,
    grabbable,
    scalable,
    scaleMin,
    scaleMax,
    hasAnimations,
    animationName,
  } = options;

  const imports = [
    'World',
    'Interactable',
    'DistanceGrabbable',
    'TwoHandsGrabbable',
    'MovementMode',
  ];

  // –ö–æ–¥ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ GLTF
  const loaderCode = `
// Load model using GLTFLoader
const loader = new GLTFLoader();
const gltf = await loader.loadAsync('${modelPath}');
const mesh = gltf.scene;
`;

  // –ö–æ–¥ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏
  const animationCode = hasAnimations ? `
// Setup animation
let mixer: AnimationMixer | null = null;
let animationId: number;
if (gltf.animations && gltf.animations.length > 0) {
  mixer = new AnimationMixer(mesh);
  const clip = gltf.animations.find(a => a.name.toLowerCase().includes('${animationName || 'walk'}')) || gltf.animations[0];
  const action = mixer.clipAction(clip);
  action.play();

  // Animation update loop
  let lastTime = 0;
  const animate = (time: number) => {
    if (mixer) {
      const delta = (time - lastTime) / 1000;
      lastTime = time;
      mixer.update(delta);
    }
    animationId = requestAnimationFrame(animate);
  };
  animationId = requestAnimationFrame(animate);

  // Register cleanup for hot reload
  (window as any).__onCleanup(() => {
    if (animationId) {
      cancelAnimationFrame(animationId);
      console.log('üßπ Cancelled animation frame for ${modelId}');
    }
    if (mixer) {
      mixer.stopAllAction();
    }
  });
}
` : '';

  // –ö–æ–¥ –¥–ª—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
  const interactionCode = grabbable || scalable ? `
// Add interaction components
entity.addComponent(Interactable);
${grabbable ? `
entity.addComponent(DistanceGrabbable, {
  movementMode: MovementMode.MoveFromTarget,
  translate: true,
  rotate: true,
  scale: false,
});` : ''}
${scalable ? `
entity.addComponent(TwoHandsGrabbable, {
  translate: true,
  rotate: true,
  scale: true,
  scaleMin: [${scaleMin}, ${scaleMin}, ${scaleMin}],
  scaleMax: [${scaleMax}, ${scaleMax}, ${scaleMax}],
});` : ''}
` : '';

  return `/**
 * Spawned Model: ${modelId}
 * Generated by spawn_model tool
 */

import {
  ${imports.join(',\n  ')},
} from '@iwsdk/core';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
${hasAnimations ? "import { AnimationMixer } from 'three';" : ''}

const world = (window as any).__IWSDK_WORLD__ as World;

(async () => {
  ${loaderCode}

  // Position and scale
  mesh.position.set(${position[0]}, ${position[1]}, ${position[2]});
  mesh.scale.setScalar(${scale});

  // Create entity
  const entity = world.createTransformEntity(mesh);
  ${interactionCode}
  ${animationCode}

  // Track for hot-reload cleanup
  (window as any).__trackEntity(entity, mesh);

  console.log('‚úì Spawned model: ${modelId}');
})();
`;
}

export const spawnModelTool = betaZodTool({
  name: 'spawn_model',
  description: `Spawn a 3D model from the library into the scene. Adds interaction components (grab, rotate, scale). Use list_models first to see available models.

Features:
- Grabbable: User can grab and move the model with VR controllers
- Scalable: User can scale the model with two hands (pinch gesture)
- Animations: Auto-plays walk/run animation if available`,

  inputSchema: z.object({
    modelId: z.string()
      .describe('Model ID from the library (e.g., "zombie-001"). Use list_models to see available IDs.'),

    position: z.tuple([z.number(), z.number(), z.number()]).optional()
      .describe('Position [x, y, z] in meters. Default: [0, 1, -2] (1m high, 2m in front)'),

    scale: z.number().optional()
      .describe('Initial scale. Default: 1'),

    grabbable: z.boolean().optional()
      .describe('Enable grab interaction. Default: true'),

    scalable: z.boolean().optional()
      .describe('Enable two-hand scaling. Default: true'),

    scaleRange: z.tuple([z.number(), z.number()]).optional()
      .describe('Scale limits [min, max]. Default: [0.1, 5]'),
  }),

  run: async (input) => {
    const toolLogger = logger.child({ module: 'tool:spawn_model' });

    const {
      modelId,
      position = [0, 1, -2],
      scale = 1,
      grabbable = true,
      scalable = true,
      scaleRange = [0.1, 5],
    } = input;

    toolLogger.info({ modelId, position, scale }, 'Spawning model');

    try {
      // 1. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏
      const exists = await modelExists(modelId);
      if (!exists) {
        throw new Error(`Model "${modelId}" not found in library. Use list_models to see available models.`);
      }

      // 2. –ü–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
      const meta = await getModelMeta(modelId);
      if (!meta) {
        throw new Error(`Failed to read metadata for model "${modelId}"`);
      }

      // 3. –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥
      const code = generateSpawnCode({
        modelId,
        modelPath: getModelGlbPath(modelId),
        position: position as [number, number, number],
        scale,
        grabbable,
        scalable,
        scaleMin: scaleRange[0],
        scaleMax: scaleRange[1],
        hasAnimations: meta.animations.length > 0,
        animationName: meta.animations[0],
      });

      // 4. –ó–∞–ø–∏—Å–∞—Ç—å —Ñ–∞–π–ª
      await fs.mkdir(GENERATED_DIR, { recursive: true });
      const fileName = `spawned-${modelId}.ts`;
      const filePath = path.join(GENERATED_DIR, fileName);
      await fs.writeFile(filePath, code);

      toolLogger.info({ filePath }, 'Spawn code written');

      // 5. Vite HMR will automatically detect and reload the file
      toolLogger.info(
        { filePath: `src/generated/${fileName}` },
        'File saved - Vite HMR will handle compilation and reload'
      );

      // 6. –†–µ–∑—É–ª—å—Ç–∞—Ç
      const interactionInfo = [];
      if (grabbable) interactionInfo.push('grabbable (distance grab)');
      if (scalable) interactionInfo.push(`scalable (${scaleRange[0]}x - ${scaleRange[1]}x)`);
      const animInfo = meta.animations.length > 0
        ? `\n**Animation:** ${meta.animations[0]} (auto-playing)`
        : '';

      return `‚úÖ Model spawned successfully!

**Model:** ${modelId} ("${meta.name}")
**Position:** [${position.join(', ')}]
**Scale:** ${scale}
**Interactions:** ${interactionInfo.join(', ')}${animInfo}
**File:** src/generated/${fileName}

The model is now in the scene. User can:
- Grab and move it with one hand
- Scale it by pinching with two hands
${meta.animations.length > 0 ? '- Watch the animation play' : ''}`;

    } catch (error: any) {
      toolLogger.error({ modelId, error: error.message }, 'Failed to spawn model');
      throw new Error(`Failed to spawn model: ${error.message}`);
    }
  }
});

/**
 * –°–ø–∞–≤–Ω –º–æ–¥–µ–ª–∏ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ (–¥–ª—è –≤—ã–∑–æ–≤–∞ –∏–∑ meshyTool)
 */
export async function spawnModelProgrammatic(options: {
  modelId: string;
  position?: [number, number, number];
  scale?: number;
  grabbable?: boolean;
  scalable?: boolean;
  scaleRange?: [number, number];
}): Promise<{ success: boolean; filePath?: string; error?: string }> {
  try {
    const result = await spawnModelTool.run({
      modelId: options.modelId,
      position: options.position,
      scale: options.scale,
      grabbable: options.grabbable,
      scalable: options.scalable,
      scaleRange: options.scaleRange,
    });

    return { success: true, filePath: `src/generated/spawned-${options.modelId}.ts` };
  } catch (error: any) {
    return { success: false, error: error.message };
  }
}
