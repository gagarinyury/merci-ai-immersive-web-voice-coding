/**
 * Spawn Model Tool
 *
 * –°–ø–∞–≤–Ω–∏—Ç 3D –º–æ–¥–µ–ª—å –∏–∑ –±–∏–±–ª–∏–æ—Ç–µ–∫–∏ –≤ —Å—Ü–µ–Ω—É.
 * –î–æ–±–∞–≤–ª—è–µ—Ç Interactable + Grabbable + TwoHandsGrabbable (–¥–ª—è –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞–Ω–∏—è).
 *
 * Flow:
 * 1. –ü—Ä–æ–≤–µ—Ä—è–µ—Ç —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏ –≤ –±–∏–±–ª–∏–æ—Ç–µ–∫–µ
 * 2. –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç TypeScript –∫–æ–¥ —Å GLTFLoader
 * 3. –ó–∞–ø–∏—Å—ã–≤–∞–µ—Ç –≤ src/generated/
 * 4. Hot-reload —á–µ—Ä–µ–∑ WebSocket
 */

import { betaZodTool } from '@anthropic-ai/sdk/helpers/beta/zod';
import { z } from 'zod';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { logger } from '../utils/logger.js';
import { getModelMeta, getModelGlbPath, modelExists } from './modelUtils.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const GENERATED_DIR = path.join(__dirname, '../../../src/generated');

/**
 * –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥ –¥–ª—è —Å–ø–∞–≤–Ω–∞ –º–æ–¥–µ–ª–∏
 */
function generateSpawnCode(options: {
  modelId: string;
  modelPath: string;
  position: [number, number, number];
  scale: number;
  grabbable: boolean;
  scalable: boolean;
  scaleMin: number;
  scaleMax: number;
  hasAnimations: boolean;
  animationName?: string;
}): string {
  const {
    modelId,
    modelPath,
    position,
    scale,
    grabbable,
    scalable,
    scaleMin,
    scaleMax,
    hasAnimations,
    animationName,
  } = options;

  const imports = [
    'World',
    'Interactable',
    'DistanceGrabbable',
    'TwoHandsGrabbable',
    'MovementMode',
  ];

  // –ö–æ–¥ –¥–ª—è –∑–∞–≥—Ä—É–∑–∫–∏ GLTF —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π Draco
  const loaderCode = `
// Load model using GLTFLoader with Draco support
const loader = new GLTFLoader();
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
loader.setDRACOLoader(dracoLoader);

const gltf = await loader.loadAsync('${modelPath}');
const mesh = gltf.scene;
`;

  // –ö–æ–¥ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–∏ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç __GAME_UPDATE__ –≤–º–µ—Å—Ç–æ requestAnimationFrame –¥–ª—è XR —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏)
  const animationCode = hasAnimations ? `
// Setup animation using __GAME_UPDATE__ (works in XR mode!)
let mixer: AnimationMixer | null = null;
if (gltf.animations && gltf.animations.length > 0) {
  mixer = new AnimationMixer(mesh);
  const clip = gltf.animations.find(a => a.name.toLowerCase().includes('${animationName || 'walk'}')) || gltf.animations[0];
  const action = mixer.clipAction(clip);
  action.play();
}

// Animation update via __GAME_UPDATE__ (XR compatible)
const prevGameUpdate = (window as any).__GAME_UPDATE__;
(window as any).__GAME_UPDATE__ = (delta: number) => {
  if (prevGameUpdate) prevGameUpdate(delta);
  if (mixer) mixer.update(delta);
};
` : '';

  // –ö–æ–¥ –¥–ª—è –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –≤–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏—è
  // DistanceGrabbable —Å scale: true –ø–æ–∑–≤–æ–ª—è–µ—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å –î–í–£–ú–Ø –õ–£–ß–ê–ú–ò
  // TwoHandsGrabbable –ø–æ–∑–≤–æ–ª—è–µ—Ç –º–∞—Å—à—Ç–∞–±–∏—Ä–æ–≤–∞—Ç—å –ü–†–Ø–ú–´–ú –ö–ê–°–ê–ù–ò–ï–ú (squeeze)
  const interactionCode = grabbable || scalable ? `
// Add interaction components
entity.addComponent(Interactable);
${grabbable ? `
entity.addComponent(DistanceGrabbable, {
  movementMode: MovementMode.MoveFromTarget,
  translate: true,
  rotate: true,
  scale: ${scalable},
  ${scalable ? `scaleMin: [${scaleMin}, ${scaleMin}, ${scaleMin}],
  scaleMax: [${scaleMax}, ${scaleMax}, ${scaleMax}],` : ''}
});` : ''}
${scalable ? `
entity.addComponent(TwoHandsGrabbable, {
  translate: true,
  rotate: true,
  scale: true,
  scaleMin: [${scaleMin}, ${scaleMin}, ${scaleMin}],
  scaleMax: [${scaleMax}, ${scaleMax}, ${scaleMax}],
});` : ''}
` : '';

  return `/**
 * Spawned Model: ${modelId}
 * Generated by spawn_model tool
 */

import {
  ${imports.join(',\n  ')},
} from '@iwsdk/core';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
${hasAnimations ? "import { AnimationMixer } from 'three';" : ''}

const world = (window as any).__IWSDK_WORLD__ as World;

(async () => {
  ${loaderCode}

  // Position and scale
  mesh.position.set(${position[0]}, ${position[1]}, ${position[2]});
  mesh.scale.setScalar(${scale});

  // Create entity
  const entity = world.createTransformEntity(mesh);
  ${interactionCode}
  ${animationCode}

  console.log('‚úì Spawned model: ${modelId}');

  // Vite HMR cleanup
  if (import.meta.hot) {
    import.meta.hot.accept();
    import.meta.hot.dispose(() => {
      entity.destroy();
      mesh.traverse((child: any) => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach((m: any) => m.dispose());
          } else {
            child.material.dispose();
          }
        }
      });
      console.log('üßπ Cleaned up model: ${modelId}');
    });
  }
})();
`;
}

export const spawnModelTool = betaZodTool({
  name: 'spawn_model',
  description: `Spawn a 3D model from the library into the scene. Adds interaction components (grab, rotate, scale). Use list_models first to see available models.

Features:
- Grabbable: User can grab and move the model with VR controllers
- Scalable: User can scale the model with two hands (pinch gesture)
- Animations: Auto-plays walk/run animation if available`,

  inputSchema: z.object({
    modelId: z.string()
      .describe('Model ID from the library (e.g., "zombie-001"). Use list_models to see available IDs.'),

    position: z.tuple([z.number(), z.number(), z.number()]).optional()
      .describe('Position [x, y, z] in meters. Default: [0, 1, -2] (1m high, 2m in front)'),

    scale: z.number().optional()
      .describe('Initial scale. Default: 1'),

    grabbable: z.boolean().optional()
      .describe('Enable grab interaction. Default: true'),

    scalable: z.boolean().optional()
      .describe('Enable two-hand scaling. Default: true'),

    scaleRange: z.tuple([z.number(), z.number()]).optional()
      .describe('Scale limits [min, max]. Default: [0.1, 5]'),
  }),

  run: async (input) => {
    const toolLogger = logger.child({ module: 'tool:spawn_model' });

    const {
      modelId,
      position = [0, 1, -2],
      scale = 1,
      grabbable = true,
      scalable = true,
      scaleRange = [0.1, 5],
    } = input;

    toolLogger.info({ modelId, position, scale }, 'Spawning model');

    try {
      // 1. –ü—Ä–æ–≤–µ—Ä–∏—Ç—å —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –º–æ–¥–µ–ª–∏
      const exists = await modelExists(modelId);
      if (!exists) {
        throw new Error(`Model "${modelId}" not found in library. Use list_models to see available models.`);
      }

      // 2. –ü–æ–ª—É—á–∏—Ç—å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
      const meta = await getModelMeta(modelId);
      if (!meta) {
        throw new Error(`Failed to read metadata for model "${modelId}"`);
      }

      // 3. –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –∫–æ–¥
      const code = generateSpawnCode({
        modelId,
        modelPath: getModelGlbPath(modelId),
        position: position as [number, number, number],
        scale,
        grabbable,
        scalable,
        scaleMin: scaleRange[0],
        scaleMax: scaleRange[1],
        hasAnimations: meta.animations.length > 0,
        animationName: meta.animations[0],
      });

      // 4. –ó–∞–ø–∏—Å–∞—Ç—å —Ñ–∞–π–ª
      await fs.mkdir(GENERATED_DIR, { recursive: true });
      const fileName = `current-model.ts`;
      const filePath = path.join(GENERATED_DIR, fileName);
      await fs.writeFile(filePath, code);

      toolLogger.info({ filePath }, 'Spawn code written');

      // 5. –û—Ç–ø—Ä–∞–≤–∏—Ç—å —Å–æ–±—ã—Ç–∏–µ file_created —á–µ—Ä–µ–∑ SSE
      const sseEmitter = (global as any).__SSE_EMITTER__;
      if (sseEmitter?.emit) {
        sseEmitter.emit({ type: 'file_created', filePath: `src/generated/${fileName}` });
      }

      // 6. Vite HMR will automatically detect and reload the file
      toolLogger.info(
        { filePath: `src/generated/${fileName}` },
        'File saved - Vite HMR will handle compilation and reload'
      );

      // 7. –†–µ–∑—É–ª—å—Ç–∞—Ç
      const interactionInfo = [];
      if (grabbable) interactionInfo.push('grabbable (distance grab)');
      if (scalable) interactionInfo.push(`scalable (${scaleRange[0]}x - ${scaleRange[1]}x)`);
      const animInfo = meta.animations.length > 0
        ? `\n**Animation:** ${meta.animations[0]} (auto-playing)`
        : '';

      return `‚úÖ Model spawned successfully!

**Model:** ${modelId} ("${meta.name}")
**Position:** [${position.join(', ')}]
**Scale:** ${scale}
**Interactions:** ${interactionInfo.join(', ')}${animInfo}
**File:** src/generated/${fileName}

The model is now in the scene. User can:
- Grab and move it with one hand
- Scale it by pinching with two hands
${meta.animations.length > 0 ? '- Watch the animation play' : ''}`;

    } catch (error: any) {
      toolLogger.error({ modelId, error: error.message }, 'Failed to spawn model');
      throw new Error(`Failed to spawn model: ${error.message}`);
    }
  }
});

/**
 * –°–ø–∞–≤–Ω –º–æ–¥–µ–ª–∏ –ø—Ä–æ–≥—Ä–∞–º–º–Ω–æ (–¥–ª—è –≤—ã–∑–æ–≤–∞ –∏–∑ meshyTool)
 */
export async function spawnModelProgrammatic(options: {
  modelId: string;
  position?: [number, number, number];
  scale?: number;
  grabbable?: boolean;
  scalable?: boolean;
  scaleRange?: [number, number];
}): Promise<{ success: boolean; filePath?: string; error?: string }> {
  try {
    const result = await spawnModelTool.run({
      modelId: options.modelId,
      position: options.position,
      scale: options.scale,
      grabbable: options.grabbable,
      scalable: options.scalable,
      scaleRange: options.scaleRange,
    });

    return { success: true, filePath: `src/generated/current-model.ts` };
  } catch (error: any) {
    return { success: false, error: error.message };
  }
}
