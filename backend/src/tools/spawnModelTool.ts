/**
 * Spawn Model Tool
 *
 * Спавнит 3D модель из библиотеки в сцену.
 * Добавляет Interactable + Grabbable + TwoHandsGrabbable (для масштабирования).
 *
 * Flow:
 * 1. Проверяет существование модели в библиотеке
 * 2. Генерирует TypeScript код с GLTFLoader
 * 3. Записывает в src/generated/
 * 4. Hot-reload через WebSocket
 */

import { betaZodTool } from '@anthropic-ai/sdk/helpers/beta/zod';
import { z } from 'zod';
import fs from 'fs/promises';
import path from 'path';
import { fileURLToPath } from 'url';
import { logger } from '../utils/logger.js';
import { getModelMeta, getModelGlbPath, modelExists } from './modelUtils.js';
import { getLiveCodeServer } from './injectCode.js';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const GENERATED_DIR = path.join(__dirname, '../../../src/generated');

/**
 * Генерировать код для спавна модели
 */
function generateSpawnCode(options: {
  modelId: string;
  modelPath: string;
  position: [number, number, number];
  scale: number;
  grabbable: boolean;
  scalable: boolean;
  scaleMin: number;
  scaleMax: number;
  hasAnimations: boolean;
  animationName?: string;
}): string {
  const {
    modelId,
    modelPath,
    position,
    scale,
    grabbable,
    scalable,
    scaleMin,
    scaleMax,
    hasAnimations,
    animationName,
  } = options;

  const imports = [
    'World',
    'Interactable',
    'DistanceGrabbable',
    'TwoHandsGrabbable',
    'MovementMode',
  ];

  // Код для загрузки GLTF
  const loaderCode = `
// Load model using GLTFLoader
const loader = new GLTFLoader();
const gltf = await loader.loadAsync('${modelPath}');
const mesh = gltf.scene;
`;

  // Код для анимации
  const animationCode = hasAnimations ? `
// Setup animation
let mixer: AnimationMixer | null = null;
if (gltf.animations && gltf.animations.length > 0) {
  mixer = new AnimationMixer(mesh);
  const clip = gltf.animations.find(a => a.name.toLowerCase().includes('${animationName || 'walk'}')) || gltf.animations[0];
  const action = mixer.clipAction(clip);
  action.play();

  // Animation update system
  let lastTime = 0;
  const animate = (time: number) => {
    if (mixer) {
      const delta = (time - lastTime) / 1000;
      lastTime = time;
      mixer.update(delta);
    }
    requestAnimationFrame(animate);
  };
  requestAnimationFrame(animate);
}
` : '';

  // Код для компонентов взаимодействия
  const interactionCode = grabbable || scalable ? `
// Add interaction components
entity.addComponent(Interactable);
${grabbable ? `
entity.addComponent(DistanceGrabbable, {
  movementMode: MovementMode.MoveFromTarget,
  translate: true,
  rotate: true,
  scale: false,
});` : ''}
${scalable ? `
entity.addComponent(TwoHandsGrabbable, {
  translate: true,
  rotate: true,
  scale: true,
  scaleMin: [${scaleMin}, ${scaleMin}, ${scaleMin}],
  scaleMax: [${scaleMax}, ${scaleMax}, ${scaleMax}],
});` : ''}
` : '';

  return `/**
 * Spawned Model: ${modelId}
 * Generated by spawn_model tool
 */

import {
  ${imports.join(',\n  ')},
} from '@iwsdk/core';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
${hasAnimations ? "import { AnimationMixer } from 'three';" : ''}

const world = (window as any).__IWSDK_WORLD__ as World;

(async () => {
  ${loaderCode}

  // Position and scale
  mesh.position.set(${position[0]}, ${position[1]}, ${position[2]});
  mesh.scale.setScalar(${scale});

  // Create entity
  const entity = world.createTransformEntity(mesh);
  ${interactionCode}
  ${animationCode}

  // Track for hot-reload cleanup
  (window as any).__trackEntity(entity, mesh);

  console.log('✓ Spawned model: ${modelId}');
})();
`;
}

export const spawnModelTool = betaZodTool({
  name: 'spawn_model',
  description: `Spawn a 3D model from the library into the scene. Adds interaction components (grab, rotate, scale). Use list_models first to see available models.

Features:
- Grabbable: User can grab and move the model with VR controllers
- Scalable: User can scale the model with two hands (pinch gesture)
- Animations: Auto-plays walk/run animation if available`,

  inputSchema: z.object({
    modelId: z.string()
      .describe('Model ID from the library (e.g., "zombie-001"). Use list_models to see available IDs.'),

    position: z.tuple([z.number(), z.number(), z.number()]).optional()
      .describe('Position [x, y, z] in meters. Default: [0, 1, -2] (1m high, 2m in front)'),

    scale: z.number().optional()
      .describe('Initial scale. Default: 1'),

    grabbable: z.boolean().optional()
      .describe('Enable grab interaction. Default: true'),

    scalable: z.boolean().optional()
      .describe('Enable two-hand scaling. Default: true'),

    scaleRange: z.tuple([z.number(), z.number()]).optional()
      .describe('Scale limits [min, max]. Default: [0.1, 5]'),
  }),

  run: async (input) => {
    const toolLogger = logger.child({ module: 'tool:spawn_model' });

    const {
      modelId,
      position = [0, 1, -2],
      scale = 1,
      grabbable = true,
      scalable = true,
      scaleRange = [0.1, 5],
    } = input;

    toolLogger.info({ modelId, position, scale }, 'Spawning model');

    try {
      // 1. Проверить существование модели
      const exists = await modelExists(modelId);
      if (!exists) {
        throw new Error(`Model "${modelId}" not found in library. Use list_models to see available models.`);
      }

      // 2. Получить метаданные
      const meta = await getModelMeta(modelId);
      if (!meta) {
        throw new Error(`Failed to read metadata for model "${modelId}"`);
      }

      // 3. Генерировать код
      const code = generateSpawnCode({
        modelId,
        modelPath: getModelGlbPath(modelId),
        position: position as [number, number, number],
        scale,
        grabbable,
        scalable,
        scaleMin: scaleRange[0],
        scaleMax: scaleRange[1],
        hasAnimations: meta.animations.length > 0,
        animationName: meta.animations[0],
      });

      // 4. Записать файл
      await fs.mkdir(GENERATED_DIR, { recursive: true });
      const fileName = `spawned-${modelId}.ts`;
      const filePath = path.join(GENERATED_DIR, fileName);
      await fs.writeFile(filePath, code);

      toolLogger.info({ filePath }, 'Spawn code written');

      // 5. Hot-reload через WebSocket
      const liveCodeServer = getLiveCodeServer();
      if (liveCodeServer) {
        const clientCount = liveCodeServer.getClientCount();
        if (clientCount > 0) {
          // Компилируем TypeScript
          const { typeCheckAndCompile } = await import('./typescript-checker.js');
          const result = typeCheckAndCompile(code);

          if (result.success && result.compiledCode) {
            liveCodeServer.broadcast({
              action: 'execute',
              code: result.compiledCode,
              timestamp: Date.now(),
            });
            toolLogger.info({ clientCount }, 'Code broadcast to clients');
          } else {
            toolLogger.warn({ errors: result.errors }, 'TypeScript compilation failed');
          }
        }
      }

      // 6. Результат
      const interactionInfo = [];
      if (grabbable) interactionInfo.push('grabbable (distance grab)');
      if (scalable) interactionInfo.push(`scalable (${scaleRange[0]}x - ${scaleRange[1]}x)`);
      const animInfo = meta.animations.length > 0
        ? `\n**Animation:** ${meta.animations[0]} (auto-playing)`
        : '';

      return `✅ Model spawned successfully!

**Model:** ${modelId} ("${meta.name}")
**Position:** [${position.join(', ')}]
**Scale:** ${scale}
**Interactions:** ${interactionInfo.join(', ')}${animInfo}
**File:** src/generated/${fileName}

The model is now in the scene. User can:
- Grab and move it with one hand
- Scale it by pinching with two hands
${meta.animations.length > 0 ? '- Watch the animation play' : ''}`;

    } catch (error: any) {
      toolLogger.error({ modelId, error: error.message }, 'Failed to spawn model');
      throw new Error(`Failed to spawn model: ${error.message}`);
    }
  }
});

/**
 * Спавн модели программно (для вызова из meshyTool)
 */
export async function spawnModelProgrammatic(options: {
  modelId: string;
  position?: [number, number, number];
  scale?: number;
  grabbable?: boolean;
  scalable?: boolean;
  scaleRange?: [number, number];
}): Promise<{ success: boolean; filePath?: string; error?: string }> {
  try {
    const result = await spawnModelTool.run({
      modelId: options.modelId,
      position: options.position,
      scale: options.scale,
      grabbable: options.grabbable,
      scalable: options.scalable,
      scaleRange: options.scaleRange,
    });

    return { success: true, filePath: `src/generated/spawned-${options.modelId}.ts` };
  } catch (error: any) {
    return { success: false, error: error.message };
  }
}
