/**
 * Spawned Model: character-001
 * Generated by spawn_model tool
 */

import {
  World,
  Interactable,
  DistanceGrabbable,
  TwoHandsGrabbable,
  MovementMode,
} from '@iwsdk/core';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { DRACOLoader } from 'three/examples/jsm/loaders/DRACOLoader.js';
import { AnimationMixer } from 'three';

const world = (window as any).__IWSDK_WORLD__ as World;

(async () => {
  
// Load model using GLTFLoader with Draco support
const loader = new GLTFLoader();
const dracoLoader = new DRACOLoader();
dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.7/');
loader.setDRACOLoader(dracoLoader);

const gltf = await loader.loadAsync('/models/character-001/model.glb');
const mesh = gltf.scene;


  // Position and scale
  mesh.position.set(1, 0, -2);
  mesh.scale.setScalar(1);

  // Create entity
  const entity = world.createTransformEntity(mesh);
  
// Add interaction components
entity.addComponent(Interactable);

entity.addComponent(DistanceGrabbable, {
  movementMode: MovementMode.MoveFromTarget,
  translate: true,
  rotate: true,
  scale: true,
  scaleMin: [0.1, 0.1, 0.1],
  scaleMax: [5, 5, 5],
});

entity.addComponent(TwoHandsGrabbable, {
  translate: true,
  rotate: true,
  scale: true,
  scaleMin: [0.1, 0.1, 0.1],
  scaleMax: [5, 5, 5],
});

  
// Setup animation using __GAME_UPDATE__ (works in XR mode!)
let mixer: AnimationMixer | null = null;
if (gltf.animations && gltf.animations.length > 0) {
  mixer = new AnimationMixer(mesh);
  const clip = gltf.animations.find(a => a.name.toLowerCase().includes('walk')) || gltf.animations[0];
  const action = mixer.clipAction(clip);
  action.play();
}

// Animation update via __GAME_UPDATE__ (XR compatible)
const prevGameUpdate = (window as any).__GAME_UPDATE__;
(window as any).__GAME_UPDATE__ = (delta: number) => {
  if (prevGameUpdate) prevGameUpdate(delta);
  if (mixer) mixer.update(delta);
};


  console.log('âœ“ Spawned model: character-001');

  // Vite HMR cleanup
  if (import.meta.hot) {
    import.meta.hot.accept();
    import.meta.hot.dispose(() => {
      entity.destroy();
      mesh.traverse((child: any) => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach((m: any) => m.dispose());
          } else {
            child.material.dispose();
          }
        }
      });
      console.log('ðŸ§¹ Cleaned up model: character-001');
    });
  }
})();
