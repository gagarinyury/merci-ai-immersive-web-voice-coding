/**
 * Spawned Model: character-001
 * Generated by spawn_model tool
 */

import {
  World,
  Interactable,
  DistanceGrabbable,
  TwoHandsGrabbable,
  MovementMode,
} from '@iwsdk/core';
import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
import { AnimationMixer } from 'three';

const world = (window as any).__IWSDK_WORLD__ as World;

(async () => {
  
// Load model using GLTFLoader
const loader = new GLTFLoader();
const gltf = await loader.loadAsync('/models/character-001/model.glb');
const mesh = gltf.scene;


  // Position and scale
  mesh.position.set(0, 0, -2);
  mesh.scale.setScalar(1);

  // Create entity
  const entity = world.createTransformEntity(mesh);
  
// Add interaction components
entity.addComponent(Interactable);

entity.addComponent(DistanceGrabbable, {
  movementMode: MovementMode.MoveFromTarget,
  translate: true,
  rotate: true,
  scale: false,
});

entity.addComponent(TwoHandsGrabbable, {
  translate: true,
  rotate: true,
  scale: true,
  scaleMin: [0.1, 0.1, 0.1],
  scaleMax: [5, 5, 5],
});

  
// Setup animation
let mixer: AnimationMixer | null = null;
let animationId: number;
if (gltf.animations && gltf.animations.length > 0) {
  mixer = new AnimationMixer(mesh);
  const clip = gltf.animations.find(a => a.name.toLowerCase().includes('walk')) || gltf.animations[0];
  const action = mixer.clipAction(clip);
  action.play();

  // Animation update loop
  let lastTime = 0;
  const animate = (time: number) => {
    if (mixer) {
      const delta = (time - lastTime) / 1000;
      lastTime = time;
      mixer.update(delta);
    }
    animationId = requestAnimationFrame(animate);
  };
  animationId = requestAnimationFrame(animate);

  // Register cleanup for hot reload
  (window as any).__onCleanup(() => {
    if (animationId) {
      cancelAnimationFrame(animationId);
      console.log('ðŸ§¹ Cancelled animation frame for character-001');
    }
    if (mixer) {
      mixer.stopAllAction();
    }
  });
}


  console.log('âœ“ Spawned model: character-001');

  // Vite HMR cleanup
  if (import.meta.hot) {
    import.meta.hot.accept();
    import.meta.hot.dispose(() => {
      entity.destroy();
      mesh.traverse((child: any) => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach((m: any) => m.dispose());
          } else {
            child.material.dispose();
          }
        }
      });
      console.log('ðŸ§¹ Cleaned up model: character-001');
    });
  }
})();
